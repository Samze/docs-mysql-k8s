---
title: Accessing MySQL Instances
owner: MySQL
---
<% current_page.data.title = "Accessing a " + vars.product_short + " Instance" %>

<strong><%= modified_date %></strong>

This topic describes how to access a <%= vars.product_full %> instance.

## <a id='prereq'></a>Prerequisites

Before accessing a MySQL instance, you must have:

* The Kubernetes Command Line Interface (kubectl) installed.
For more information, see the [Kubernetes documentation](https://kubernetes.io/docs/tasks/tools/install-kubectl/).

## <a id='verify-settings'></a> (Optional) Verify MySQL Instance Settings

To see all MySQL instance settings configured:

1. Access the MySQL container.

    ```
    kubectl -n DEVELOPMENT-NAMESPACE exec --stdin --tty pod/INSTANCE-NAME-0 -c mysql -- /bin/bash
    ```
    In this command, replace:
    * `DEVELOPMENT-NAMESPACE` with the namespace of the <%= vars.product_short %> instance
    * `INSTANCE-NAME` with the name of the instance

    For example:

    <pre class="terminal">
    kubectl -n my-namespace exec --stdin --tty pod/mysql-sample-0 -c mysql -- /bin/bash
    </pre>

1. Review the configuration files `/etc/mysql/conf.d/base.cnf` and `/etc/mysql/conf.d/autotune.cnf`.

## <a id='server-login'></a> Root Access to the MySQL Server

Database administrative operations (such as creating users and databases) require connecting
to MySQL as the root database user.  <%= vars.product_short %> only allows root account
connections from within the container running the database; off-container root connections are not permitted.

To connect to the MySQL instance as the MySQL root user:

1. Access the MySQL container.

    ```
    kubectl -n DEVELOPMENT-NAMESPACE exec --stdin --tty pod/INSTANCE-NAME-0 -c mysql -- /bin/bash
    ```
    In this command, replace:
    * `DEVELOPMENT-NAMESPACE` with the namespace of the <%= vars.product_short %> instance
    * `INSTANCE-NAME` with the name of the instance

    For example:

    <pre class="terminal">
    kubectl -n my-namespace exec --stdin --tty pod/mysql-sample-0 -c mysql -- /bin/bash
    </pre>

1. Log in to the MySQL server.

    ```
    mysql -uroot -p$(cat $MYSQL_ROOT_PASSWORD_FILE)
    ```

    For example:

    <pre class="terminal">
    $ mysql -uroot -p$(cat $MYSQL_ROOT_PASSWORD_FILE)
    </pre>

## <a id='off-platform-access'></a> Access the MySQL Server from an External IP Address

<p class="note">
<strong>Note:</strong> This procedure requires that your cloud provider supports external load balancers. For more information about the <code>LoadBalancer</code> service type, see the
  <a href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer">Kubernetes documentation</a>.
</p>

In order to connect to a <%= vars.product_short %> instance from outside of your Kubernetes cluster, you must configure the Kubernetes service for the instance to be of type `LoadBalancer` rather than the default `ClusterIP`.

To access the MySQL server from an external IP address:

1. Create a database user to use for the external connection. For more information, see [Create a Database
and Privileged MySQL User for the Application](bind-app.html#create-app-db).

1. If the <%= vars.product_short %> instance does not have a `Spec.ServiceType` value of <code>LoadBalancer</code>:

    1. Update the instance and change the value of the `Spec.ServiceType` property to <code>LoadBalancer</code>. For more information about updating an instance, see [Updating MySQL Instances](update-instance.html). For more information about the properties used by a <%= vars.product_short %> instance, see <a href="./property-reference-mysql.html">Property Reference for the MySQL Resource</a>.
    <p>&nbsp;</p>
    1. Verify that the `ServiceType` is `LoadBalancer` instead of the default `ClusterIP`.

        ```
        kubectl get service INSTANCE-NAME -o jsonpath={.spec.type}
        ```
        In this command, replace `INSTANCE-NAME` with the value of the `metadata.name` property for the MySQL instance.
        <br /><br />
        For example:

        <pre class="terminal">
        $ kubectl get service mysql-sample -o jsonpath={.spec.type}
        LoadBalancer
        </pre>

1. Find the external IP address allocated for the service.

    ```
    kubectl get service INSTANCE-NAME -o jsonpath={.status.loadBalancer.ingress[].ip}
    ```
    In this command, replace `INSTANCE-NAME` with the value of the `metadata.name` property for the MySQL instance.
    <br /><br />
    For example:

    <pre class="terminal">
    $ kubectl get service mysql-sample -o jsonpath="{.status.loadBalancer.ingress[*]['ip', 'hostname']}"
    192.168.64.200
    </pre>

    This command retrieves either an IP address or a resolvable DNS hostname.
    <br /><br />
    If the command returns a DNS hostname, use the hostname in place of the IP address in the following examples.
    For example, an AWS load balancer returns a domain name instead of an IP address.

    <pre class="terminal">
    $ kubectl get service mysql-sample -o jsonpath="{.status.loadBalancer.ingress[*]['ip', 'hostname']}"
    a4dc8de1biefe13112-17761231.us-west-2.elb.amazonaws.com
    </pre>

1. Log in to the MySQL server.

    ```
    mysql -u USERNAME -pUSER-PASSWORD -P 3306 -h EXTERNAL-IP
    ```
    In this command, replace:
    * `USERNAME` with the name of the MySQL user (created in Step 1)
    * `USER-PASSWORD` with the password you assigned to the MySQL user (created in Step 1)
    * `EXTERNAL-IP` with the external IP address allocated for the MySQL service (retrieved in Step 3)

    For example:

    <pre class="terminal">
    $ mysql -u report_admin -phunter2 -P 3306 -h a4dc8de1biefe13112-17761231.us-west-2.elb.amazonaws.com
    </pre>

### <a id='remove-off-platform-access'></a> Turn Off External Access

To disable off-platform connections:

1. Update the <%= vars.product_short %> instance and change the value of the `Spec.ServiceType` property to <code>ClusterIP</code>.
    For more information about how to change a property, see [Change Other Configurations](./update-instance.html#other-config).

<p class="note">
<strong>Note:</strong> When you change the <code>Spec.ServiceType</code> from <code>LoadBalancer</code> to <code>ClusterIP</code>, your cloud provider may automatically delete the associated load balancer for the MySQL instance.
</p>


## <a id='port-forward'></a> Access the MySQL Server from the Kubernetes API Server

<p class="note"> <strong>Note:</strong> This procedure proxies the connection to MySQL through the Kubernetes API server. It is intended for debugging access, and its performance is slower than that of a direct connection.  </p>

To access the MySQL server from the Kubernetes API server:

1. Get the MySQL root user password. The root user password is available in the Kubernetes secret named after
  the MySQL instance with a `-credentials` suffix.

    ```
    MYSQL_ROOT_PASSWORD=$(kubectl get secret INSTANCE-NAME-credentials -o go-template='{{.data.rootPassword | base64decode}}')
    ```
    In this command, replace `INSTANCE-NAME` with the name of the MySQL instance.

1. Start a port-forwarding proxy using the `kubectl port-forward` command. For more information
about this command, see the [Kubernetes documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward).

    ```
    kubectl port-forward service/INSTANCE-NAME 3306 &
    ```

    For example:

    <pre class="terminal">
    $ kubectl port-forward service/mysql-sample 3306 &
    <br />Forwarding from 127.0.0.1:3306 -> 3306
    Forwarding from [::1]:3306 -> 3306
    </pre>

1. Connect to the service through the poxy port.
    <br /><br />
    For example, to connect using the MySQL client:

    <pre class="terminal">
    $ mysql -h 127.0.0.1 -u root -P 3306 -p${MYSQL_ROOT_PASSWORD}
    </pre>

1. When finished, stop the proxy by stopping the kubectl process.
    <br /><br />
    For example:

    <pre class="terminal">
    $ jobs
    [1]+  Running    kubectl port-forward service/mysql-sample 3306 & <br />
    $ kill %1
    </pre>

## <a id='app-connect'></a> Access MySQL From Cluster-Hosted Applications

For each instance, <%= vars.product_short %> creates a Kubernetes service, which is used to connect an app to its MySQL database.
The service is named after the Tanzu SQL for Kubernetes instance.

If an app is deployed on the Kubernetes cluster, the app can access the MySQL instance using the DNS name
of the MySQL service. This DNS name is only resolvable within the Kubernetes cluster.

An app should connect to the database using a narrowly-privileged database user created for the specific requirements of the app.
For information about creating a user for an app and connecting the app to a database using specific user and configuration information, see [Connecting Apps to MySQL Instances](./bind-app.html).

---
title: Creating and Deleting a Tanzu MySQL Instance
owner: MySQL
---

<%= partial '../../mysql-k8s/partials/mysql-k8s/product-beta-warning' %>

<strong><%= modified_date %></strong>

This topic describes how you, as a developer, deploy and delete <%= vars.product_short %> instances.

## <a id='prerequisites'></a> Prerequisites

Before you can create or delete <%= vars.product_short %> instances, you must have:

* The Kubernetes Command Line Interface (kubectl).
  See [Installing the Kubernetes CLI](https://docs.pivotal.io/tkgi/installing-kubectl-cli.html).

* Full admin access to all Kubernetes resources in your developer namespace.

    For information about Roles and RoleBindings that your Kubernetes cluster admin needs to create,
    see the [Kubernetes documentation](https://kubernetes.io/docs/reference/access-authn-authz/rbac/).

* The URL and credentials to access the registry that stores the <%= vars.product_short %> images.
  This can the TanzuNet registry or the private registry configured for your environment.
    If you do not have access to the registry credentials, contact your kubernetes administrator
    to have these set up for you in your namespace.

## <a id='create-instance'></a>Create a Tanzu MySQL Instance

From your namespace, Kubernetes must be able to access the registry that stores the <%= vars.product_short %> images
To create a Tanzu MySQL instance:

1. Target the development namespace where you want to create the Tanzu MySQL instance.

2. From your namespace, Kubernetes must be able to access the registry
   that stores the <%= vars.product_short %> images. 
   In order to do allow this, create an imagePullSecret by running:

    <code>
kubectl --namespace=DEVELOPMENT-NAMESPACE create secret docker-registry tanzu-mysql-image-registry --docker-server=REGISTRY-SERVER-URL --docker-username=DOCKER-USERNAME --docker-password=DOCKER-PASSWORD
</code>

    Where:
    * `DEVELOPMENT-NAMESPACE` is the namespace in which you want to create the instance  
    * `REGISTRY-SERVER-URL` is the TanzuNet registry or the private registry configured for your environment
    * `DOCKER-USERNAME` and `DOCKER-PASSWORD` are the credentials used to pull images from the registry.  

    For example:

    <pre class="terminal">$ kubectl create secret --namespace=my-namespace \
    docker-registry tanzu-mysql-image-registry  \
    --docker-server=https://registry.pivotal.io/ \
    --docker-username=sample-username  \
    --docker-password=sample-password
    secret/tanzu-mysql-image-registry created
    </pre>

3. Create a `tanzumysql.yaml` file.
   You can use this as a template.

    ```
    apiVersion: mysql.tanzu.vmware.com/v1alpha1
    kind: TanzuMySQL
    metadata:
      name: tanzumysql-sample
    spec:
      storageSize: 1Gi
      imagePullSecret: tanzu-mysql-image-registry

    #### Set the storage class name to change storage class of the PVC associated with this resource
    #  storageClassName: standard

    #### Examples to set resource limit/request for mysql/backup pods.

    #  resources:

    #### This is the container running the mysql server.
    #    mysql:
    #      limits:
    #        cpu: 3
    #        memory: 800Mi
    #      requests:
    #        cpu: 2
    #        memory: 500Mi
    #### This is the sidecar container that takes a backup and streams to the storage backend.
    #    backups:
    #      limits:
    #        cpu: 2
    #        memory: 500Mi
    #      requests:
    #        cpu: 1
    #        memory: 200Mi
    ```

4. Edit the `tanzumysql.yaml` file.
   For an explanation of the the properties you can set in this file,
   see [Property Reference for tanzumysql.yml](#tanzumysql.yaml) below.


5. Deploy a Tanzu MySQL instance to Kubernetes by running:

    ```
    kubectl -n DEVELOPMENT-NAMESPACE apply -f tanzumysql.yaml
    ```

    For example:

    <pre class="terminal">$ kubectl -n my-namespace apply -f tanzumysql.yaml
    tanzumysql.mysql.tanzu.vmware.com/tanzumysql-sample created
    </pre>


6. Verify that the instance was created successfully by running:

    ```
    kubectl get tanzumysql INSTANCE-NAME
    ```

    Where `INSTANCE-NAME` is the value that you configured for `metadata.name` in the `tanzumysql.yaml` file.

    For example:

    <pre class="terminal">$ kubectl get tanzumysql tanzumysql-sample
NAME                READY   STATUS    AGE
tanzumysql-sample   true    Running   2m17s
    </pre> 



## <a id='delete-instance'></a>Delete a Tanzu MySQL instance


You get a PVC when you create the instance. 
The PVC name contains the instance name. 
mysql-data-INSTANCE-NAME-N

One PVC for each MySQL pod. Right now, only one. Thus, always 0. 
The PVC contains the data.

You can delete an instance and leave the PVC storing the data.
If you subsequently want to access the data, you create a new instance with the same name as the deleted instance. 
The PVC will automatically reattach to the new instance.

<p class="note">
   <strong>Note:</strong> If you delete the Pod or Statefulset associated
   with the <%= vars.product_short %> resource,
   a <%= vars.product_short %> controller recreates it for you.
   If you want to permanently delete the instance, you need to delete the <code>tanzumysql</code> resource.
</p>

To delete a Tanzu MySQL instance:

1. Delete the Tanzu MySQL instance by running:

    <code>kubectl -n DEVELOPMENT-NAMESPACE delete tanzumysql INSTANCE-NAME </code>

    Where:
    * `DEVELOPMENT-NAMESPACE` is the  
    * `INSTANCE-NAME` is the name of the instance you want to delete.

    For example:

    <pre class="terminal">
    $ kubectl delete tanzumysql tanzumysql-sample
tanzumysql.mysql.tanzu.vmware.com "tanzumysql-sample" deleted
    </pre>

2. (Optional) Delete the Persistent Volume Claim (PVC) as well.

    <p class="note warning">
       <strong> Warning:</strong> This is a destructive action.
       If you destroy your PVC, you are deleting all data associated with your <%= vars.product_short %> database.
    </p>

    1. Review your PVCs by running:

          <code>kubectl get pvc </code>

          For example:

          <pre class="terminal">
       $ kubectl get pvc
NAME                              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
mysql-data-tanzumysql-sample-0    Bound    pvc-3262e841-c4aa-4aa4-b53a-68cd3078f806   1Gi        RWO            standard       7d1h
mysql-data-another-sample-0       Bound    pvc-87c8a3a9-263b-46e6-8acb-ed474434fd24   1Gi        RWO            standard       6d21h
          </pre>
    2. Determine the name of the PVCs that correspond to the name of the instance you deleted above.

    3. Delete the PVC associated with each Tanzu MySQL Pod by running, for each pod:

          <code>kubectl delete pvc mysql-data-INSTANCE-NAME-n  </code>
 
          Where:
          + INSTANCE-NAME is the name of the TanzuMySQL instance that you deleted
          + n is the index of each pod in the TanzuMySQL instance

          For example:

          <pre class="terminal">
       $ kubectl delete pvc mysql-data-tanzumysql-sample-0
persistentvolumeclaim "mysql-data-tanzumysql-sample-0" deleted
          </pre>




##<a id="tanzumysql-yaml"></a> Property Reference for tanzumysql.yml

The table below explains the properties that can be set in the `tanzumysql.yml` file
created in [#create-instance](#) above.

<table class="nice">
<th>Property</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
<th>Example</th>
<th>Required?</th>
<tr>
  <td>metadata.name</td>
  <td>String</td>
  <td>None</td>
  <td>The name of your Tanzu MySQL instance. Must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. For more information, see http://kubernetes.io/docs/user-guide/identifiers#names</td>
  <td>my-instance</td>
  <td>Yes</td>
</tr>
<tr>
  <td>spec.storageSize</td>
  <td></td>
  <td>None</td>
  <td>StorageSize specifies the size of the persistent volume claims for the <%= vars.product_short %> pods. Unit of measure can be M for Megabyte, for example. For more information about what units are expected for persistent volume claim sizes, see <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/resources.md#resource-quantities">this Github page</a>.

  </td>
  <td>50Gi</td>
  <td>Yes</td>
</tr>
<tr>
  <td>spec.imagePullSecret</td>
  <td>String</td>
  <td>None</td>
  <td>Refers to an existing Kubernetes docker-registry secret that can access the registry that contains the TanzuMySQL image.</td>
  <td>tanzu-mysql-image-registry</td>
  <td>Yes</td>
</tr>
<tr>
  <td>spec.storageClassName</td>
  <td>String</td>
  <td>Standard</td>
  <td>Specifies the StorageClass for the persistent volume claims for the <%= vars.product_short %> pods. For the types of StorageClasses available, contact your Kubernetes administrator. For more information about the Kubernetes StorageClass concept, see this doc:https://kubernetes.io/docs/concepts/storage/storage-classes/</td>
  <td>standard</td>
  <td>No</td>
</tr>
<tr>
  <td>spec.resources.mysql</td>
  <td>
    <ul>
      <li>limits.cpu</li>
      <li>limits.memory</li>
    </ul>
  </td>
  <td>Best Effort</td>
  <td>Describes the maximum amount of compute resources (CPU, Memory) allowed for the MySQL container. If left blank, Kubernetes will do best effort to allocate necessary compute resources for the MySQL container. For more information, see: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/</td>
  <td>limits.cpu: 3 , limits.memory: 800Mi</td>
  <td>No</td>
</tr>
<tr>
  <td>spec.resources.mysql</td>
  <td>
    <ul>
      <li>requests.cpu</li>
      <li>requests.memory</li>
    </ul>
  </td>
  <td>Best Effort</td>
  <td>Describes the minimum amount of compute resources (CPU, Memory) allowed for the MySQL container. If left blank, it defaults to Limits if that is explicitly specified. For more information, see: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/</td>
  <td>requests.cpu: 2 , requests.memory: 500Mi</td>
  <td>No</td>
</tr>
<tr>
  <td>spec.resources.backups</td>
  <td>
    <ul>
      <li>limits.cpu</li>
      <li>limits.memory</li>
    </ul>
  </td>
  <td>Best Effort</td>
  <td>Describes the maximum amount of compute resources (CPU, Memory) allowed for the backups container. If left blank, Kubernetes will do best effort to allocate necessary compute resources for the backups container. For more information, see: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/</td>
  <td>limits.cpu: 2 , limits.memory: 500Mi</td>
  <td>No</td>
</tr>
<tr>
  <td>spec.resources.backups</td>
  <td>
    <ul>
      <li>requests.cpu</li>
      <li>requests.memory</li>
    </ul>
  </td>
  <td>Best Effort</td>
  <td>Describes the minimum amount of compute resources (CPU, Memory) allowed for the backups container. If left blank, it defaults to Limits if that is explicitly specified. For more information, see: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/</td>
  <td>requests.cpu: 1 , requests.memory: 200Mi</td>
  <td>No</td>
</tr>
</table>


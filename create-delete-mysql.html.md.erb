---
title: Creating and Deleting MySQL Instances
owner: MySQL
---

This topic describes how to create and delete MySQL instances.

## <a id='prerequisites'></a> Prerequisites

Before you can create or delete MySQL instances, you must have:

[//]: # (This partial contains a standard set of prereqs. Also used in high-availability topic.)
<%= partial '/prerequisites' %>

## <a id='download-templates'></a> Download the Deployment Templates

In order to create <%= vars.product_full %> instances, you must first download the deployment templates from Tanzu Network.
You use these templates to create configuration files that specify the Tanzu MySQL for Kubernetes resources that you wish to create.

<p class='note'><strong>Note:</strong> You only need to download the templates once (before you first create a MySQL instance).</p>

To access the templates:

1. Log in to [<%= vars.product_network %>](https://network.pivotal.io).

1. Visit the **<%= vars.product_full %>** product page.

1. Click **VMware Tanzu SQL with MySQL for Kubernetes v1.1.0**. This will download a .tgz archive file to your local machine.

1. Expand the downloaded .tgz file. Open the directory `tanzu-mysql-for-kubernetes-1.1.0`. The templates are located in the `samples` subdirectory.

The templates include the following:

* `backup.yaml` (for the MySQLBackup resource)
* `backuplocation.yaml` (for the MySQLBackupLocation resource)
* `backupschedule.yaml` (for the MySQLBackupSchedule resource)
* `mysql.yaml` (for the MySQL resource; this template is used to create MySQL instances)
* `restore.yaml` (for the MySQLRestore resource)
* `tls-secret.yaml` (for a [TLS Secret](https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets))

You do not need to download the **Artifact References** from the Tanzu MySQL for Kubernetes product page.

## <a id='create-instance'></a>Create a MySQL Instance

To create a MySQL instance, a `MySQL` resource definition must be created and applied. The Tanzu MySQL Operator creates
the necessary resources, such as Secrets, Services and Statefulsets, in the same namespace where the MySQL instance was
defined.

First, create a `MySQL` resource named `mysql.yaml`:

```bash
$ cat > mysql.yaml <<EOF
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
  name: my-instance
spec:
  storageSize: 1Gi
```

**Note:** `storageSize` is a required parameter which defines the size of the disk used for the MySQL Database Server.

Next, apply this file to the kubernetes cluster:

```bash
$ kubectl apply --filename=mysql.yaml
mysql/my-instance created
```

Then, verify the instance was successfully created by running:

```bash
$ kubectl get all --selector "app.kubernetes.io/instance=mysql-sample"
NAME                 READY   STATUS    RESTARTS   AGE
pod/mysql-sample-0   3/3     Running   0          27s

NAME                           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)              AGE
service/mysql-sample           ClusterIP   10.111.245.250   <none>        3306/TCP,33060/TCP   27s
service/mysql-sample-members   ClusterIP   None             <none>        3306/TCP,33060/TCP   27s

NAME                            READY   AGE
statefulset.apps/mysql-sample   1/1     27s
```

The MySQL instance is now ready to be used by an application.


## <a id='configure-instance'></a>Configure a MySQL Instance

To configure a MySQL instance open the mysql.yaml that was previously created or edit the configuration in place by running:

```bash
$ kubectl edit mysql my-instance
```

Next, add any of the properties described below along with their values.  Every property listed below is optional, except `storageSize`

<a id="instance-storageSize"></a>**storageSize**

Description: The capacity of the persistent volume, expressed as a Kubernetes resource quantity.

Default Value: No default. This is a required value.

Example:

```yaml
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 10Gi
```

Notes:

A 1Gi disk is the minimum recommended value.  The value to use in your environment will depend on the size of your database and your expected data growth.  Talk to your local database administrator for more details.


<a id="instance-storageClassName"></a>**storageClassName**

Description: The name of the [Kubernetes StorageClass](https://kubernetes.io/docs/concepts/storage/storage-classes/) to
use when creating a [Kubernetes persistent volume](https://kubernetes.io/docs/concepts/storage/persistent-volumes/). 
This volume is used by the MySQL Database Server to persist data files.

Default Value: No default specified.  The default storage class of the Kubernetes cluster will be used, if any.

Example:

```yaml
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
```

Notes:

If no default storageClass is defined in the Kubernetes cluster, then `storageClassName` is a required option in order
for a MySQL instance to start successfully.

Run the following class to see available storageClasses in your cluster:

```bash
$ kubectl get storageclasses
```

<a id="instance-imagePullSecretName"></a>**imagePullSecretName**

Description: A reference to a [Kubernetes
Secret](https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets) containing registry
credentials.  This secret will be configured on Kubernetes Pods to retrieve the Tanzu MySQL instance images from the
registry configured when the Tanzu MySQL Operator was installed.

Default Value: "tanzu-image-registry"

Example:

```yaml
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
   imagePullSecretName: "my-local-pull-secret"
```

Notes:

To create a Kubernetes registry secret, run this command:

```bash
$ kubectl create secret docker-registry my-local-pull-secret --docker-server=MY-REGISTRY.DOMAIN --docker-username=MY-REGISTRY-USERNAME --docker-password=MY-REGISTRY-PASSWORD
```

<a id="instance-serviceType"></a>**serviceType**

Description: Specify the [Kubernetes Service](https://kubernetes.io/docs/concepts/services-networking/service/) type for the MySQL Service. This configures an endpoint for an application or database client to connect to the database instance.

TODO: Reference "Connect to your MySQL Instance Docs"

The valid types for a Tanzu MySQL instance are:
 - ClusterIP
 - LoadBalancer

Default Value: "ClusterIP"

Example:

```yaml
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
   serviceType: "LoadBalancer"
```

Notes:

Tanzu MySQL does not support other service types such as `ExternalName` or `NodePort` that are otherwise supported by a standalone Kubernetes Service.


<a id="instance-tls-secret-name"></a>**tls.secret.name**

Description: Configure the MySQL instance to use the certificates provided by the [Kubernetes TLS Secret](https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets) referenced by this property. The
Secret must already exist in the same Namespace as the `MySQL` instance. The Secret MUST contain
`tls.key`, `tls.crt` and `ca.crt` for the private key, public certificate and certificate authority respectively.

TODO: Reference "Configuring TLS docs"

Default Value: cert-manager managed secret created via the cert-manager/ClusterIssuer configured when installing the Tanzu MySQL Operator.

Example:

```yaml
---
apiVersion: v1
kind: Secret
metadata:
   name: my-custom-secret-name
type: kubernetes.io/tls
data:
   # the data is abbreviated in this example
   ca.crt: |
      MIIC2DCCAcCgAwIBAgIBATANBgkqh ...
   tls.crt: |
      MIIC2DCCAcCgAwIBAgIBATANBgkqh ...
   tls.key: |
      MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
   tls:
     secret:
       name: "my-custom-secret-name"
```

Notes:

This is an entirely optional value when a user desires to customize the TLS certificates used by the Tanzu MySQL Operator.

It is recommended that secrets are created by creating cert-manager certificates so that they are automatically
refreshed before they expire.  This is not enforced by the Tanzu MysQL Operator, and if a user provides "static"
certificates that are not managed they may expire without warning and prevent TLS connections to the MySQL database.

<a id="instance-highAvailability-enabled"></a>**highAvailability.enabled**

Description: Configures the MySQL instance to be a high-availability cluster with 3 redundant pods and 2 proxy pods. 

After being set to true, cannot be modified or update for an existing instance. 
For information about high availability, see [Configuring MySQL Instances for High Availability](high-availability.html). 

TODO: Reference "Configuring TLS docs"

Default Value: false.  A MySQL instance will create a single pod running a single copy of the MySQL Database Server.

Example:

```yaml
---
apiVersion: v1
kind: Secret
metadata:
   name: my-custom-secret-name
type: kubernetes.io/tls
data:
   # the data is abbreviated in this example
   ca.crt: |
      MIIC2DCCAcCgAwIBAgIBATANBgkqh ...
   tls.crt: |
      MIIC2DCCAcCgAwIBAgIBATANBgkqh ...
   tls.key: |
      MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
   tls:
     secret:
       name: "my-custom-secret-name"
```

Notes:

This is an entirely optional value when a user desires to customize the TLS certificates used by the Tanzu MySQL Operator.

It is recommended that secrets are created by creating cert-manager certificates so that they are automatically
refreshed before they expire.  This is not enforced by the Tanzu MysQL Operator, and if a user provides "static"
certificates that are not managed they may expire without warning and prevent TLS connections to the MySQL database.

<a id="instance-databasePodConfig"></a>**databasePodConfig**

Description: Configures advanced Kubernetes Pod rules for [Affinity and
Anti-Affinity](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity) and
[Tolerations](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration) for MySQL Database pods.


Default Value: preferred anti-affinity between pods for the same Tanzu MySQL instance so that each pod will preferably run on different [Kubernetes Nodes](https://kubernetes.io/docs/concepts/architecture/nodes/).  This default only affects
instances configures with <a href="#instance-highAvailability-enabled">high-availability</a>.

Example:

```yaml
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
   databasePodConfig:
     affinity:
       podAntiAffinity:
         requiredDuringSchedulingIgnoredDuringExecution:
           - weight: 1
             podAffinityTerm:
               topologyKey: "kubernetes.io/hostname"
               labelSelector:
                 matchExpressions:
                   - key: "app.kubernetes.io/component"
                     operator: In
                     values:
                       - database
                   - key: "app.kubernetes.io/instance"
                     operator: In
                     values:
                       - my-instance
```

Notes:

TODO: Wordsmithing

This is an advanced configuration option to allow a MySQL instance to run on specific nodes or tolerate specific kinds
of Kubernetes Node failures gracefully.


<a id="instance-databasePodConfig"></a>**proxyPodConfig**

Description: Configures advanced Kubernetes Pod rules for [Affinity and
Anti-Affinity](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity) and
[Tolerations](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration) for proxy pods used in High Availability clusters. 


Default Value: preferred anti-affinity between pods for the same Tanzu MySQL instance so that each pod will preferably run on different [Kubernetes Nodes](https://kubernetes.io/docs/concepts/architecture/nodes/).  This default only affects
instances configures with <a href="#instance-highAvailability-enabled">high-availability</a>.

Example:

```yaml
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
   proxyPodConfig:
     affinity:
       podAntiAffinity:
         requiredDuringSchedulingIgnoredDuringExecution:
           - weight: 1
             podAffinityTerm:
               topologyKey: "kubernetes.io/hostname"
               labelSelector:
                 matchExpressions:
                   - key: "app.kubernetes.io/component"
                     operator: In
                     values:
                       - proxy
                   - key: "app.kubernetes.io/instance"
                     operator: In
                     values:
                       - my-instance
```

Notes:

TODO: Wordsmithing

This is an advanced configuration option to allow a MySQL instance to run on specific nodes or tolerate specific kinds
of Kubernetes Node failures gracefully.


<a id="instance-resources"></a>**resources**

Description: Specify the resource requests and limits of the `MySQL` containers for a given instance. CPU requirements
must be in CPU units. Memory requirements must be in bytes. Both values must be expressed as a [Kubernetes Resource
Quantity](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes)

Default Value: No default.  All MySQL pods run with [Kubernetes Best Effort quality-of-service (QoS)](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/#create-a-pod-that-gets-assigned-a-qos-class-of-besteffort)

Example:

```yaml
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
   resources: 
     ### This is the container running the mysql server.
     mysql:
       requests:
         cpu: 750m
         memory: 500Mi
       limits:
         cpu: '1.0'
         memory: 800Mi 
     ### This is the sidecar container that manages backups and highAvailability cluster operations
     mysqlSidecar:
       requests:
         cpu: 100m
         memory: 50Mi
       limits:
         cpu: 250m
         memory: 75Mi 
     ### This is the container that exports metrics
     metrics:
       requests:
         cpu: 100m
         memory: 32Mi
       limits:
         cpu: 250m
         memory: 75Mi

     ### This is the container that proxies connections to MySQL when highAvailability.enabled is true
     proxy:
       requests:
         cpu: 200m
         memory: 48Mi
       limits:
         cpu: '1.0'
         memory: 256Mi
```

Notes:

Specific values will depend on capacity planning for the database instance.  Above example is only for sample purposes
and only suitable for a low traffic database.  More demanding workloads will require higher values.

<a id="instance-persistentVolumeClaimPolicy"></a>**persistentVolumeClaimPolicy**

Description: Configures the retention for the persistent disk when the MySQL instance is deleted

Valid Values:
- Retain
- Delete

Default Value: Retain

Example:

```yaml
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
   persistentVolumeClaimPolicy: Delete
```

Notes:

By default, if a MySQL instance is deleted the Persistent Volume is preserved in the Kubernetes cluster.  A user will need to manually delete that volume at a later time if they no longer wish to preserve that data.

If a user wishes to automatically remove Persistent Volumes when a MySQL instance is deleted,
persistentVolumeClaimPolicy must be explicitly configured with the value `Delete`.


<a id="instance-version"></a>**version**

Description: Configures the Tanzu MySQL version to configure an instance

Valid Values:
- 1.0.0
- 1.1.0
- 1.2.0

Default Value: 1.2.0, but default may be overridden when installing the Tanzu MySQL Operator

Example:

```yaml
---
apiVersion: with.sql.tanzu.vmware.com/v1
kind: MySQL
metadata:
   name: my-instance
spec:
   storageSize: 1Gi
   version: "1.2.0"
```

Notes:

This property exists to support MySQL upgrades.   When an instance is created by the 1.1.0 operator, and that operator
is later upgraded to 1.2.0 the instance will _not_ be automatically updated.  This avoids unexpected downtime by
automatically restarting the instance.  

However, in order for a user to take advantage of features in the latest operator, the instance `spec.version` should be
configured to the latest supported version.

## <a id='create-instance'></a>Create a MySQL Instance

[//]: # (Note to authors: if you change step numbers in this procedure, edit high-availability topic.)

To create a MySQL instance:

1. Target the namespace where you want to create the MySQL instance:

    ```
    kubectl config set-context --current --namespace=DEVELOPMENT-NAMESPACE
    ```
    Where `DEVELOPMENT-NAMESPACE` is the namespace in which you want to create the instance.
    <br><br>
    For example:
    <pre class="terminal">$ kubectl config set-context --current --namespace=my-namespace
    </pre>

2. From your namespace, Kubernetes must be able to access the registry
   that stores the <%= vars.product_short %> images.
   To allow this, create an imagePullSecret by running:

    ```
    kubectl --namespace=DEVELOPMENT-NAMESPACE create secret docker-registry tanzu-mysql-image-registry --docker-server=REGISTRY-SERVER-URL --docker-username=DOCKER-USERNAME --docker-password=DOCKER-PASSWORD
    ```
    Where:
    * `DEVELOPMENT-NAMESPACE` is the namespace in which you want to create the instance
    * `REGISTRY-SERVER-URL` is the <%= vars.product_network %> registry or the private registry configured for your environment
    * `DOCKER-USERNAME` and `DOCKER-PASSWORD` are the credentials used to pull images from the registry.

    For example:

    <pre class="terminal">$ kubectl create secret --namespace=my-namespace \
    docker-registry tanzu-mysql-image-registry  \
    --docker-server=https://registry.pivotal.io/ \
    --docker-username=sample-username  \
    --docker-password=sample-password

    secret/tanzu-mysql-image-registry created
    </pre>

3. Find the `mysql.yaml` deployment template that you downloaded
   in the TGZ file from <%= vars.product_network %>.
   For how to download deployment templates, see [Download the Deployment Templates](#download-templates).

4. Create a copy of the `mysql.yaml` file and give it a unique name.
    <br><br>
    For example:

    <pre class="terminal">$ cp ~/Downloads/tanzu-mysql-deployment-templates-1.0.0/samples/mysql.yaml testdb.yaml</pre>


5. Edit the file.
   For information about the properties that you can set for the MySQL resource,
   see [Property Reference for the MySQL Resource](property-reference-mysql.html).

6. Deploy a MySQL instance to Kubernetes by running:

    ```
    kubectl -n DEVELOPMENT-NAMESPACE apply -f FILENAME
    ```
    Where `FILENAME` is the name of the configuration file you created in Step 4 above.
    <br><br>
    For example:

    <pre class="terminal">$ kubectl -n my-namespace apply -f testdb.yaml
    mysql.with.sql.tanzu.vmware.com/mysql-sample created
    </pre>


7. Verify that the instance was created successfully by running:

    ```
    kubectl -n DEVELOPMENT-NAMESPACE get mysql INSTANCE-NAME
    ```
    Where `INSTANCE-NAME` is the value that you configured for `metadata.name` in your file
    <br><br>
    For example:

    <pre class="terminal">$ kubectl -n my-namespace get mysql mysql-sample
NAME           READY   STATUS    AGE
mysql-sample   true    Running   2m17s
    </pre>


## <a id='delete-instance'></a>Delete a MySQL Instance

This section provides some conceptual information about persistent volume claims (PVCs)
and deleting an instance.
It also provides the procedure for how to delete an instance.

###<a id="about-pvcs"></a> About PVCs

When you create a MySQL instance, the MySQL Operator also creates PVCs.
The PVCs are attached to the instance and contain the data for the MySQL database.
Single-node instances have one PVC, and high-availability (HA) instances have three.

The PVC name contains the instance name and the MySQL Pod number.
The PVC name is of the form <code>mysql-data-INSTANCE-NAME-N</code>,
for example, `mysql-data-mysql-sample-0`.


###<a id="about-deleting"></a> About Deleting a MySQL Instance

There are two steps to deleting an instance.
The first step is to delete the instance itself, and the second step is to delete the PVCs.

There are situations where you want to delete the instance but not delete the PVC.
For example, in a test environment, you might delete the instance to save costs
but keep the PVC storing the data.
If you later create a new instance with the same name as the deleted instance,
the old PVCs automatically reattach to the new instance and you have access to your data again.

<p class="note">
   <strong>Note:</strong> If you delete the Pod or the StatefulSet associated
   with the MySQL resource, the Operator re-creates it for you.
   To permanently delete the instance, you need to delete the MySQL resource,
   as described in step 1 below.
</p>

###<a id="procedure"></a> Procedure

To delete a MySQL instance:

1. Delete the MySQL instance by running:

    ```
    kubectl -n DEVELOPMENT-NAMESPACE delete mysql INSTANCE-NAME
    ```

    Where:
    * `DEVELOPMENT-NAMESPACE` is the namespace where you created the instance.
    * `INSTANCE-NAME` is the name of the instance you want to delete.

    For example:

    <pre class="terminal">
    $ kubectl -n my-namespace delete mysql mysql-sample
    my-namespace "mysql-sample" deleted
    </pre>

2. (Optional) Delete the PVCs by running:

    <p class="note warning">
       <strong> Warning:</strong> This command is destructive.
       When you destroy your PVCs, you delete all data associated with your <%= vars.product_short %> database.
    </p>

    ```
    kubectl delete pvc -l app.kubernetes.io/instance=INSTANCE-NAME
    ```

    Where `INSTANCE-NAME` is the name of the MySQL instance that you deleted above.
    <br><br>
    For example:

    <pre class="terminal">
   $ kubectl delete pvc -l app.kubernetes.io/instance=mysql-sample
persistentvolumeclaim "mysql-data-mysql-sample-0" deleted</pre>

    <p class="note">
        <strong> Note:</strong> For HA MySQL instances, the command deletes
        all three PVCs associated with the MySQL instance.
    </p>
